import os
import tempfile
import time
import streamlit as st
from utils.ai_integrations import (
    process_command_with_openai,
    process_command_with_anthropic,
    process_command_with_gemini,
    process_command_with_openrouter,
    analyze_video_content,
    analyze_video_audio,
    extract_frames_for_analysis
)
from utils.video_processor import (
    process_video,
    cut_silences,
    apply_color_adjustment,
    get_video_info,
    get_video_thumbnail,
    save_video
)
from utils.interactive_timeline import (
    InteractiveTimeline,
    render_interactive_timeline,
    add_tool_panel,
    update_timeline_with_tool
)
from utils.command_processor import parse_command, execute_command
from assets.sample_templates import get_template_list, apply_template

# Set up page configuration
st.set_page_config(
    page_title="AI Video Editor",
    page_icon="üé¨",
    layout="wide", 
    initial_sidebar_state="expanded"
)

# Aplicar CSS personalizado
with open('.streamlit/style.css', 'r') as f:
    css = f.read()
    st.markdown(f'<style>{css}</style>', unsafe_allow_html=True)

# Initialize session state
if 'interactive_timeline' not in st.session_state:
    st.session_state.interactive_timeline = InteractiveTimeline()
if 'uploaded_video' not in st.session_state:
    st.session_state.uploaded_video = None
if 'processing_video' not in st.session_state:
    st.session_state.processing_video = False
if 'current_video_path' not in st.session_state:
    st.session_state.current_video_path = None
if 'video_info' not in st.session_state:
    st.session_state.video_info = None
if 'command_history' not in st.session_state:
    st.session_state.command_history = []
if 'temp_dir' not in st.session_state:
    st.session_state.temp_dir = tempfile.TemporaryDirectory()
if 'ai_model' not in st.session_state:
    st.session_state.ai_model = "OpenAI"  # Default model
if 'selected_tab' not in st.session_state:
    st.session_state.selected_tab = "AI Commands"
if 'tool_result' not in st.session_state:
    st.session_state.tool_result = None
if 'pending_video_process' not in st.session_state:
    st.session_state.pending_video_process = False

# Title and description
st.title("üé¨ AI-Powered Video Editor")
st.markdown("""
Edita tus videos con comandos en lenguaje natural o usando herramientas interactivas. 
Carga un video y dile a la IA qu√© cambios quieres hacer o usa la l√≠nea de tiempo interactiva.
""")

# Sidebar for settings and options
with st.sidebar:
    st.header("‚öôÔ∏è Ajustes")
    
    # AI Model Selection
    st.session_state.ai_model = st.selectbox(
        "Modelo de IA",
        ["OpenAI", "Google Gemini", "Anthropic Claude", "OpenRouter"],
        index=0
    )
    
    # Video Upload Section
    st.subheader("üì§ Cargar Video")
    
    # Mostrar una gu√≠a r√°pida para el usuario
    st.info("üí° **Gu√≠a r√°pida:** Carga tu video y usa los comandos de IA o las herramientas de edici√≥n que aparecer√°n abajo.")
    
    # Explicaci√≥n sobre videos grandes
    with st.expander("‚ÑπÔ∏è Informaci√≥n sobre carga de videos grandes"):
        st.write("""
        - La aplicaci√≥n acepta videos de hasta 5 GB (aproximadamente 1 hora)
        - Los videos muy grandes pueden tardar en procesarse
        - Si experimentas problemas, intenta con un archivo m√°s peque√±o primero
        """)
    
    # M√©todos de carga (pesta√±as)
    tab_file, tab_url = st.tabs(["üìÅ Desde archivo", "üîó Desde URL"])
    
    temp_path = None
    uploaded_video_name = None
    
    with tab_file:
        with st.form("upload_form", clear_on_submit=False):
            uploaded_file = st.file_uploader("Elige un archivo de video", 
                                          type=['mp4', 'mov', 'avi', 'mkv'], 
                                          accept_multiple_files=False,
                                          help="Selecciona un archivo de video de tu dispositivo")
            submit_button = st.form_submit_button("Cargar Video", type="primary")
            
            if submit_button and uploaded_file is not None:
                st.session_state.processing_video = True
                try:
                    # Mostrar barra de progreso para archivos grandes
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    
                    # Guardar el archivo cargado en bloques
                    status_text.text("Guardando el video...")
                    temp_path = os.path.join(st.session_state.temp_dir.name, uploaded_file.name)
                    chunk_size = 5*1024*1024  # 5MB por bloque
                    file_buffer = uploaded_file.getbuffer()
                    total_chunks = (len(file_buffer) // chunk_size) + 1
                    
                    with open(temp_path, 'wb') as f:
                        for i in range(0, len(file_buffer), chunk_size):
                            chunk_num = i // chunk_size
                            progress = min(1.0, chunk_num / total_chunks)
                            progress_bar.progress(progress)
                            status_text.text(f"Guardando video: {int(progress*100)}% completado")
                            f.write(file_buffer[i:i+chunk_size])
                    
                    uploaded_video_name = uploaded_file.name
                    status_text.text("Video listo para procesar")
                    
                    # Cargar el video directamente
                    st.session_state.current_video_path = temp_path
                    st.session_state.uploaded_video = type('obj', (object,), {'name': uploaded_video_name})
                    
                    # Inicializar informaci√≥n b√°sica
                    try:
                        # Obtener informaci√≥n b√°sica solo para mostrarla, si falla no es cr√≠tico
                        st.session_state.video_info = get_video_info(temp_path)
                    except:
                        st.session_state.video_info = {
                            "duration": 0.0,
                            "size": (0, 0),
                            "fps": 0.0
                        }
                    
                    # Inicializar la l√≠nea de tiempo interactiva
                    try:
                        st.session_state.interactive_timeline = InteractiveTimeline(temp_path)
                    except Exception as e:
                        st.warning(f"‚ö†Ô∏è Se ha cargado el video, pero hubo un problema inicializando la l√≠nea de tiempo: {str(e)}")
                        st.session_state.interactive_timeline = InteractiveTimeline()
                    
                    # Finalizar
                    st.session_state.processing_video = False
                    status_text.success(f"‚úÖ Video cargado: {uploaded_video_name}")
                    # Esperar un momento para que el usuario vea el mensaje
                    time.sleep(0.5)
                    st.rerun()
                except Exception as e:
                    st.error(f"Error cargando el video: {str(e)}")
                    st.session_state.processing_video = False
    
    with tab_url:
        with st.form("url_form", clear_on_submit=False):
            video_url = st.text_input("Introduce la URL del video:",
                                   help="Introduce una URL directa a un archivo de video (.mp4, .mov, .avi, .mkv)")
            submit_url_button = st.form_submit_button("Descargar Video", type="primary")
            
            if submit_url_button and video_url:
                st.session_state.processing_video = True
                try:
                    # Mostrar barra de progreso
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    status_text.text(f"Conectando a {video_url}...")
                    
                    # Descargar el video
                    import requests
                    response = requests.get(video_url, stream=True)
                    if response.status_code != 200:
                        raise Exception(f"Error al descargar el video: C√≥digo {response.status_code}")
                    
                    # Obtener el tama√±o total si est√° disponible
                    total_size = int(response.headers.get('content-length', 0))
                    
                    # Crear un nombre de archivo para el video descargado
                    video_filename = video_url.split('/')[-1]
                    if not video_filename.endswith(('.mp4', '.mov', '.avi', '.mkv')):
                        video_filename = f"video_descargado.mp4"
                    
                    temp_path = os.path.join(st.session_state.temp_dir.name, video_filename)
                    
                    # Descargar en bloques con barra de progreso
                    downloaded = 0
                    with open(temp_path, 'wb') as f:
                        for chunk in response.iter_content(chunk_size=1024*1024):  # 1MB por chunk
                            if chunk:
                                f.write(chunk)
                                downloaded += len(chunk)
                                if total_size > 0:
                                    progress = min(1.0, downloaded / total_size)
                                    progress_bar.progress(progress)
                                    status_text.text(f"Descargando video: {int(progress*100)}% completado")
                    
                    uploaded_video_name = video_filename
                    status_text.text("Video listo para procesar")
                    
                    # Cargar el video directamente
                    st.session_state.current_video_path = temp_path
                    st.session_state.uploaded_video = type('obj', (object,), {'name': uploaded_video_name})
                    
                    # Inicializar informaci√≥n b√°sica
                    try:
                        # Obtener informaci√≥n b√°sica solo para mostrarla, si falla no es cr√≠tico
                        st.session_state.video_info = get_video_info(temp_path)
                    except:
                        st.session_state.video_info = {
                            "duration": 0.0,
                            "size": (0, 0),
                            "fps": 0.0
                        }
                    
                    # Inicializar la l√≠nea de tiempo interactiva
                    try:
                        st.session_state.interactive_timeline = InteractiveTimeline(temp_path)
                    except Exception as e:
                        st.warning(f"‚ö†Ô∏è Se ha cargado el video, pero hubo un problema inicializando la l√≠nea de tiempo: {str(e)}")
                        st.session_state.interactive_timeline = InteractiveTimeline()
                    
                    # Finalizar
                    st.session_state.processing_video = False
                    status_text.success(f"‚úÖ Video cargado: {uploaded_video_name}")
                    # Esperar un momento para que el usuario vea el mensaje
                    time.sleep(0.5)
                    st.rerun()
                except Exception as e:
                    st.error(f"Error descargando el video: {str(e)}")
                    st.session_state.processing_video = False
    
    # Ya no necesitamos procesar el video aqu√≠, se inicializa directamente durante la carga
    
    # Show templates when a video is loaded
    if st.session_state.uploaded_video is not None:
        st.subheader("üé® Plantillas de Video")
        templates = get_template_list()
        selected_template = st.selectbox("Elige una plantilla", list(templates.keys()))
        
        if st.button("Aplicar Plantilla"):
            with st.spinner("Aplicando plantilla..."):
                try:
                    new_video_path = apply_template(
                        st.session_state.current_video_path, 
                        templates[selected_template]
                    )
                    st.session_state.current_video_path = new_video_path
                    
                    # Actualizar la l√≠nea de tiempo interactiva
                    st.session_state.interactive_timeline = InteractiveTimeline(new_video_path)
                    
                    st.success(f"Plantilla aplicada: {selected_template}")
                except Exception as e:
                    st.error(f"Error aplicando la plantilla: {str(e)}")

# Mostrar siempre la gu√≠a r√°pida para hacer la interfaz m√°s clara
st.header("üé¨ EDITOR DE VIDEO INTELIGENTE")

# Mostrar video si est√° cargado
if st.session_state.current_video_path:
    # Crear dos columnas, una para el video y otra para la gu√≠a r√°pida
    col1, col2 = st.columns([3, 1])
    
    with col1:
        st.subheader("üé• Video Actual")
        
        # Video information
        if st.session_state.video_info:
            info = st.session_state.video_info
            st.write(f"Duraci√≥n: {info['duration']:.2f} segundos | Resoluci√≥n: {info['size'][0]}x{info['size'][1]} | FPS: {info['fps']:.2f}")
        
        # Display the video
        st.video(st.session_state.current_video_path)
    
    with col2:
        st.subheader("üöÄ Gu√≠a R√°pida")
        st.markdown("""
        ### Herramientas Disponibles:
        
        1. **üí¨ Comandos de IA**:
           - Escribe instrucciones en lenguaje natural
           - Ejemplos:
           - "Corta los primeros 5 segundos"
           - "A√±ade un t√≠tulo al inicio"
           - "Haz el video m√°s r√°pido"
        
        2. **‚öôÔ∏è Herramientas manuales**:
           - L√≠nea de tiempo interactiva
           - Cortar segmentos
           - Ajustes de color
           - A√±adir texto y efectos
           - Filtros visuales
           
        3. **üé¨ Plantillas**:
           - Aspecto cinematogr√°fico
           - Vintage
           - Redes sociales
        """)
else:
    # Si no hay video, mostrar un mensaje claro para el usuario
    st.info("üëÜ **Primer paso**: Carga un video usando las opciones de arriba. Una vez cargado, aparecer√° aqu√≠ y podr√°s editarlo con las herramientas de abajo.")
    
    # A√±adir una peque√±a gu√≠a visual
    st.markdown("""
    ### üõ†Ô∏è Herramientas que estar√°n disponibles despu√©s de cargar un video:
    
    **1Ô∏è‚É£ Comandos de IA:** Edita tu video con instrucciones en lenguaje natural  
    **2Ô∏è‚É£ Editor Visual:** Usa la l√≠nea de tiempo y herramientas profesionales  
    **3Ô∏è‚É£ Plantillas:** Aplica estilos predefinidos con un solo clic  
    """)

# Divisor claro
st.markdown("---")

# Mostrar siempre las pesta√±as, pero deshabilitar las funciones si no hay video
# Crear pesta√±as m√°s grandes y visibles
tab1, tab2, tab3, tab4 = st.tabs(["ü§ñ COMANDOS DE IA", "üé¨ EDITOR VISUAL", "üé® PLANTILLAS", "üîç AN√ÅLISIS DE CONTENIDO"])

# Pesta√±a de comandos de IA
with tab1:
    st.subheader("ü§ñ Edici√≥n por Comandos de Lenguaje Natural")
    
    # Ejemplos de comandos
    with st.expander("üìö Ver ejemplos de comandos"):
        st.markdown("""
        ### Ejemplos de comandos que puedes usar:
        - "Corta los primeros 5 segundos del video"
        - "Ajusta el brillo y contraste para que se vea mejor"
        - "Convierte el video a blanco y negro"
        - "A√±ade el t√≠tulo 'Mi Aventura' al inicio del video con fuente grande"
        - "Haz que el video sea un 50% m√°s r√°pido"
        - "A√±ade un efecto de desvanecimiento al final"
        - "Elimina las partes silenciosas del video"
        - "A√±ade un filtro c√°lido de color"
        - "Cambia el tama√±o del video a formato cuadrado para Instagram"
        - "A√±ade subt√≠tulos autom√°ticos"
        """)
    
    command = st.text_area("üí¨ Ingresa tu comando de edici√≥n:", 
                         height=100,
                         help="Describe los cambios que quieres hacer al video en lenguaje natural.",
                         placeholder="Ej: Reduce la velocidad del video a la mitad, aplica un filtro de color c√°lido y a√±ade el t√≠tulo 'Mi Aventura'")
    
    # Mostrar bot√≥n incluso si no hay video (pero deshabilitarlo)
    button_disabled = st.session_state.current_video_path is None
    if button_disabled:
        st.info("‚ö†Ô∏è Primero debes cargar un video para poder procesar comandos")
        
    if st.button("üî• Procesar Comando", type="primary", use_container_width=True, disabled=button_disabled):
        if command:
            # Crear componentes para indicar el progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            try:
                # FASE 1: Procesamiento de IA (25%)
                status_text.info("üß† Analizando tu comando con IA...")
                
                # Determine which AI model to use
                if st.session_state.ai_model == "OpenAI":
                    ai_response = process_command_with_openai(command, st.session_state.interactive_timeline)
                elif st.session_state.ai_model == "Anthropic Claude":
                    ai_response = process_command_with_anthropic(command, st.session_state.interactive_timeline)
                elif st.session_state.ai_model == "Google Gemini":
                    ai_response = process_command_with_gemini(command, st.session_state.interactive_timeline)
                else:  # OpenRouter
                    ai_response = process_command_with_openrouter(command, st.session_state.interactive_timeline)
                
                progress_bar.progress(25)
                status_text.info("‚úÖ Comando analizado, interpretando operaciones...")
                time.sleep(0.5)  # Peque√±a pausa para que el usuario vea el progreso
                
                # FASE 2: Parseo del comando (50%)
                operations = parse_command(command, ai_response)
                progress_bar.progress(50)
                status_text.info("‚úÖ Operaciones interpretadas, aplicando cambios al video...")
                time.sleep(0.5)  # Peque√±a pausa para que el usuario vea el progreso
                
                # FASE 3: Ejecuci√≥n de operaciones (75%)
                message, new_video_path = execute_command(
                    operations, 
                    st.session_state.current_video_path,
                    st.session_state.temp_dir.name
                )
                
                progress_bar.progress(75)
                status_text.info("‚úÖ Cambios aplicados, finalizando procesamiento...")
                time.sleep(0.5)  # Peque√±a pausa para que el usuario vea el progreso
                
                # FASE 4: Actualizaci√≥n de la UI (100%)
                # Update the current video path if a new video was generated
                if new_video_path:
                    st.session_state.current_video_path = new_video_path
                    st.session_state.video_info = get_video_info(new_video_path)
                    
                    # Actualizar la l√≠nea de tiempo interactiva
                    st.session_state.interactive_timeline = InteractiveTimeline(new_video_path)
                
                # Add to command history
                st.session_state.command_history.append({
                    "command": command,
                    "operations": operations,
                    "result": message
                })
                
                progress_bar.progress(100)
                status_text.success(f"‚úÖ {message}")
                
                # Dar tiempo al usuario para ver el resultado antes de recargar
                time.sleep(1.0)
                st.rerun()
            except Exception as e:
                progress_bar.empty()
                status_text.error(f"‚ùå Error: {str(e)}")
        else:
            st.warning("‚ö†Ô∏è Por favor, ingresa un comando.")
    
    # Command History
    if st.session_state.command_history:
        st.subheader("üìù Historial de Comandos")
        for i, cmd in enumerate(st.session_state.command_history):
            with st.expander(f"Comando {i+1}: {cmd['command'][:50]}..."):
                st.write(f"**Comando:** {cmd['command']}")
                st.write(f"**Resultado:** {cmd['result']}")
                st.write("**Operaciones:**")
                for op in cmd['operations']:
                    st.write(f"- Tipo: {op.get('type', 'Desconocido')}")
                    st.write(f"  Par√°metros: {op.get('params', {})}")
                    st.write(f"  Posici√≥n en la l√≠nea de tiempo: {op.get('timeline_position', 'todo')}")
                    st.write("---")

# Pesta√±a de herramientas de edici√≥n
with tab2:
    st.subheader("üé¨ Editor de Video Profesional")
    
    # Mensaje si no hay video cargado
    if st.session_state.current_video_path is None:
        st.info("‚ö†Ô∏è Para usar el editor visual, primero debes cargar un video")
        st.markdown("""
        ### Funciones disponibles del editor visual:
        
        - **L√≠nea de tiempo interactiva**: Para seleccionar partes espec√≠ficas del video
        - **Ajustes de color**: Brillo, contraste, saturaci√≥n, etc.
        - **Efectos visuales**: Filtros, efectos de transici√≥n, desenfoque
        - **Edici√≥n de audio**: Ajuste de volumen, silenciado, efectos
        - **T√≠tulos y textos**: A√±adir texto superpuesto al video
        """)
    else:
        # Mostrar informaci√≥n sobre el editor visual
        st.markdown("""
        Este editor te permite controlar con precisi√≥n la edici√≥n de tu video:
        1. **L√≠nea de tiempo interactiva**: Visualiza y edita tu video
        2. **Herramientas avanzadas**: Cortes, efectos, transiciones y m√°s
        3. **Control preciso**: Ajusta cada par√°metro seg√∫n tus necesidades
        """)
        
        # Renderizar la l√≠nea de tiempo interactiva
        timeline_events = render_interactive_timeline(st.session_state.interactive_timeline)
        
        # A√±adir panel de herramientas
        st.subheader("üß∞ Herramientas Disponibles")
        tool_result = add_tool_panel(st.session_state.interactive_timeline)
        
        # Si se selecciona una herramienta
        if tool_result["tool_selected"]:
            st.session_state.tool_result = tool_result
            
            # Mostrar informaci√≥n sobre la herramienta seleccionada
            st.info(f"üìå Herramienta seleccionada: **{tool_result['tool_name']}**")
            
            # Confirmar la aplicaci√≥n de la herramienta
            if st.button("‚úÖ APLICAR CAMBIOS AL VIDEO", key="apply_tool", type="primary", use_container_width=True):
                # Crear componentes para indicar el progreso
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                try:
                    # FASE 1: Preparaci√≥n (25%)
                    status_text.info(f"‚öôÔ∏è Preparando herramienta: {tool_result['tool_name']}...")
                    progress_bar.progress(25)
                    time.sleep(0.5)  # Breve pausa para que el usuario vea el progreso
                    
                    # FASE 2: Aplicaci√≥n de la herramienta (50%)
                    status_text.info(f"üîß Aplicando cambios al video...")
                    progress_bar.progress(50)
                    
                    # Aplicar la herramienta
                    new_video_path, result_message = update_timeline_with_tool(
                        st.session_state.interactive_timeline,
                        tool_result,
                        st.session_state.current_video_path
                    )
                    
                    if new_video_path:
                        # FASE 3: Procesamiento final (75%)
                        status_text.info("üé¨ Actualizando l√≠nea de tiempo...")
                        progress_bar.progress(75)
                        time.sleep(0.5)  # Breve pausa para que el usuario vea el progreso
                        
                        # FASE 4: Actualizaci√≥n de la UI (100%)
                        st.session_state.current_video_path = new_video_path
                        st.session_state.video_info = get_video_info(new_video_path)
                        
                        # Actualizar la l√≠nea de tiempo interactiva
                        st.session_state.interactive_timeline = InteractiveTimeline(new_video_path)
                        
                        progress_bar.progress(100)
                        status_text.success(f"‚úÖ {result_message}")
                        
                        # Dar tiempo al usuario para ver el resultado antes de recargar
                        time.sleep(1.0)
                        st.rerun()
                    else:
                        progress_bar.empty()
                        status_text.error(f"‚ùå {result_message}")
                except Exception as e:
                    progress_bar.empty()
                    status_text.error(f"‚ùå Error: {str(e)}")

# Pesta√±a de plantillas
with tab3:
    st.subheader("üé® Plantillas Profesionales")
    
    # Mensaje si no hay video cargado
    if st.session_state.current_video_path is None:
        st.info("‚ö†Ô∏è Para aplicar plantillas, primero debes cargar un video")
        st.markdown("""
        ### Plantillas disponibles:
        
        - **Cinematogr√°fica**: Aspecto de pel√≠cula con bandas negras y colores cinematogr√°ficos
        - **Vintage**: Estilo retro con grano de pel√≠cula y efectos de color antiguo
        - **Redes Sociales**: Optimizaci√≥n para Instagram, TikTok y otras plataformas
        - **Vlog**: Colores vibrantes y transiciones modernas
        - **Blanco y Negro**: Cl√°sico monocrom√°tico con alto contraste
        """)
    else:
        # Informaci√≥n sobre las plantillas
        st.markdown("""
        Aplica estilos profesionales con un solo clic:
        - Mejora la apariencia de tu video
        - Ahorra tiempo con ajustes preconfigurados
        - Prueba diferentes estilos
        """)
        
        # Mostrar plantillas disponibles
        templates = get_template_list()
        
        # Crear columnas para mostrar las plantillas con miniaturas
        template_cols = st.columns(3)
        
        # Informaci√≥n de plantilla seleccionada
        selected_template = st.selectbox("Elige una plantilla:", list(templates.keys()))
        
        # Mostrar descripci√≥n de la plantilla
        st.info(f"**{selected_template}:** Transforma tu video con un aspecto profesional.")
        
        # Bot√≥n grande para aplicar la plantilla
        if st.button("‚ú® APLICAR PLANTILLA", type="primary", use_container_width=True):
            # Crear componentes para indicar el progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            try:
                # FASE 1: Preparaci√≥n (25%)
                status_text.info(f"üé¨ Preparando plantilla {selected_template}...")
                progress_bar.progress(25)
                time.sleep(0.5)  # Breve pausa para que el usuario vea el progreso
                
                # FASE 2: Aplicaci√≥n de la plantilla (50%)
                status_text.info(f"üé¨ Aplicando efectos de {selected_template}...")
                progress_bar.progress(50)
                
                # Aplicar la plantilla
                new_video_path = apply_template(
                    st.session_state.current_video_path, 
                    templates[selected_template]
                )
                
                # FASE 3: Procesamiento final (75%)
                status_text.info("üé¨ Procesando video final...")
                progress_bar.progress(75)
                time.sleep(0.5)  # Breve pausa para que el usuario vea el progreso
                
                # FASE 4: Actualizaci√≥n de la UI (100%)
                st.session_state.current_video_path = new_video_path
                
                # Actualizar la l√≠nea de tiempo interactiva
                st.session_state.interactive_timeline = InteractiveTimeline(new_video_path)
                
                progress_bar.progress(100)
                status_text.success(f"‚úÖ Plantilla aplicada: {selected_template}")
                
                # Dar tiempo al usuario para ver el resultado antes de recargar
                time.sleep(1.0)
                st.rerun()
            except Exception as e:
                progress_bar.empty()
                status_text.error(f"‚ùå Error aplicando la plantilla: {str(e)}")

# Save Video Button
if st.session_state.current_video_path:
    st.subheader("üíæ Guardar Video Editado")
    
    col1, col2 = st.columns([3, 1])
    
    with col1:
        output_filename = st.text_input("Nombre del archivo de salida:", 
                                      value=f"editado_{os.path.basename(st.session_state.current_video_path)}",
                                      help="Introduce el nombre para el video editado.")
    
    with col2:
        if st.button("Guardar Video", type="primary"):
            with st.spinner("Guardando video..."):
                try:
                    saved_path = save_video(st.session_state.current_video_path, output_filename)
                    st.success(f"Video guardado como: {output_filename}")
                    st.download_button(
                        label="‚¨áÔ∏è Descargar Video",
                        data=open(saved_path, "rb").read(),
                        file_name=output_filename,
                        mime="video/mp4"
                    )
                except Exception as e:
                    st.error(f"Error guardando el video: {str(e)}")